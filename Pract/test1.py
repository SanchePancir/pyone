# -------------- ФУНКЦИИ --------------
# int = 5 , целое
number = 5
age = 28

# float = 5.7 , рациональное
fnumber = 5.7

# str = "Alex" , = strings, то есть "строка" или строка текста
name = "Alex"

# bool = True
status = True

# abs() - делает число не отрицательным
balance = -200
amount = abs(balance) 
print(amount)# => 200

# Любой комментарий

print ("Что нужно вывести")

# Экранирование
print ("Он \"плохой\" человек!")
print ('Он "плохой" человек!')

# Перевод строки
print('Привет\nмир')

# Табуляция (как принажатии на Enter)
print('Привет\tмир')

print("Привет")
print('Мир')

# Конкатенация
print("Привет, меня зовут " + name + "!" )

# Тайпкастинг - приводить переменную к другому типу
print("Мне " + str(age) + " лет!") # str = strings, то есть "строка" или строка текста

# ДАЛЕЕ
name = input("Введите своё имя: ")
age = input("Укажите свой возраст: ")
print("Привет, " + name + "!")
print("Тебе уже " + age + " лет, это круто!")

# +, -, *, /, ** (степень), % (деление по модулю, возвращается остаток), унарный минус, Пи
a = 5
b = 10
c = a + b
c = a ** 2
# Это а во 2 степени

a = 10
a = -a
# Это унарный минус. Меняет знак числа
print(c)

# Унарный минус
a = 5.65
print(round(a))

# Округление floor - в меньшую, ceil - в большую
import math
a = 5.65
print(math.floor(a))

# Число Пи "PI"
import math
print(math.PI)



# -------------- ПЕРЕМЕННЫЕ --------------
# greeting - переводится как приветствие
greeting = 'Father!'
print(greeting)
greeting1 = 'Father!' # ...И так далее
# Именование перепенный в PY используют "snake_case". То есть, с использованием "_"

# Интерполяция.  f-строка - это шаблон, в который с помощью фигурных скобок подставляются значения переменных. 
first_name = 'Joffrey'
greeting = 'Hello'
print(f'{greeting}, {first_name}!')
# Еще пример ->
school = 'Hexlet' 
what_is_it = f'{school} - online courses'
print(what_is_it)  # => Hexlet - online courses

# Multi-line строки. Нужно заключить её в тройные кавычки - """ или '''
text = '''Пример текста,
состоящего из
нескольких строк
''' # Эти ковычки можно перенести и поставить после слова "строк". Тогда пуской стоки в результате не будет
# Вместо: text = 'Пример текста,\nсостоящего из\nнескольких строк'
# Получаем 2 варианта:
stark = 'Arya'

print (f'''Do you want to eat, {stark}?
Yes, I'm hungry, mom.
''') 

print ("Do you want to eat, " + stark + "? \nYes, I'm hungry, mom.\n")

#Do you want to eat, Arya?
#Yes, I'm hungry, mom.

# Извлечение символа. Ставится в "[]" и указывается от 0 сколько символов надо. 
first_name = 'Alexander'
print(first_name[0]) # Результат -> A
print(first_name[8])  # => r
# Допустимо использовать отрицательные индексы. В этом случае идёт обращение к символам, начиная с конца строки.
print(first_name[-1])  # => r
# Вот пример, который приведёт к тому же результату — выводу на экран символа A, но индекс внутри квадратных скобок записан не числом, а переменной:
first_name = 'Alexander'
index = 0
print(first_name[index])  # => A

# Это же, но + Интерполяция:
one = 'Naharis'
two = 'Mormont'
three = 'Sand'

print (f'{one[2] + two[1] + three[-1] + two[4] + two[2]}') # -> hodor

# Еще пример:
value = '12-08-2034'
year = value[6:10]
print(year)  # => 2034
value[1:2] # Приведет к "2". Последнее число не считается (без учета последнего числа)
value[3:5] # Приведет к '08'

value = 'Hexlet'
value[3:] # 'let'
value[:3] # 'Hex'
# Мы можем указать даже отрицательные индексы. В таком случае отсчет идет с обратной стороны: value[3:-1] -> 'le'
# Левая граница отрицательная. Считаем -5 от конца строки: value[-5:3]  # 'ex'
# У срезов есть третий необязательный параметр - шаг извлечения. По умолчанию он равен единице, но мы можем его изменить:
value = 'Hexlet'
value[1:5:2]  # "el" = 1:5 это 'exle' # шаг 2 это каждый второй, то есть 'e' и 'l'
# Все это можно комбинировать с открытыми границами, то есть без указания начала или конца:
value = 'Hexlet'
value[:5:2]  # 'Hxe'
value[1::2]  # 'elt'
# Шаг может быть отрицательным, в таком случае он берется с конца. Из этого вытекает самый популярный способ использования шага - переворот строки:
value = 'Hexlet' # Пропускаем обе границы
value[::-1]  # 'telxeH'
# Срезы можно указывать не только через числа, но и с использованием переменных:
value = 'Hexlet'
start = 1
end = 5
value[start:end]  # 'exle'
print(text[2::-1]) # -> 'xeH'


# -------------- ЕЩЕ ФУНКЦИИ --------------
# Функци "len()", которая считает количество символов в строке:
result = len('Hello!') # Вызов функции len с параметром 'Hello!'
print(result)  # => 6

# Функция "pow()", которая возводит указанное число в нужную степень. 
# Она принимает на вход два параметра и возводит число, переданное первым параметром, в степень, переданную вторым параметром.
result = pow(2, 3)  # 2 * 2 * 2
print(result)  # => 8

# Функция "round()", которая округляет переданное ей число:
result = round(10.25)  # 10.0
result = round(10.25, 0)  # 10.0
result = round(10.25, 1)  # 10.2 , округление до одного знака после запятой
# Мы передали в неё два параметра: число, которое нужно округлить, и точность округления. 0 означает, что округление будет до целого значения.

# Функция max() находит максимальное значение среди переданных параметров.
max(1, 10, 3)  # 10
# Функция "random()", от 0 до 1 с множеством чисел после ","; если:
from random import random
print(int(random() * 10) + 1) # от 1 до 10 случайное число

# Функция "type" показывает какой тип данных 'str', 'int' и тд
motto = 'Family, Duty, Honor'
print(type(motto)) # -> <class 'str'>

# 'def' - Определение функции. Определение не вызывает и не выполняет функцию. Мы лишь говорим, что теперь такая функция существует
def show_greeting():
  # Внутри тела отступ 4 пробела
  text = 'Hello, Hexlet!'
  print(text.upper())
# Вызов функции
show_greeting()

# Еmail нужно подготовить к записи в базу, привести его к нижнему регистру и обрезать пробельные символы по краям строки. 
def save_email():
    # В реальности email приходит из формы
    email = "  SuppORT@hexlet.IO"
    # обрезаем пробельные символы
    trimmed_email = email.strip()
    prepared_email = trimmed_email.lower()
    print(prepared_email)
    # здесь будет запись в базу данных

# return – особая инструкция, которая берёт выражение, записанное справа, и отдаёт его наружу, тому коду, который вызвал метод. 
def greeting():
  return 'Hello, Hexlet!'
message = greeting()
print(message)
print(message.upper())

#-------------- ОБЪЕКТЫ --------------
name = 'Hexlet'
# Метод upper()
upper_name = name.upper()
print(upper_name)  # => 'HEXLET'
# ИЛИ:
'Hexlet'.upper()  # 'HEXLET'
#Атрибуты работают и выглядят как переменные, только указываются через точку после объекта.

name = 'Python'

# Возвращает индекс первого вхождения буквы в строку
name.find('t')  # 2

# Переводит в нижний регистр
name.lower()  # 'python'

# Заменяет одну подстроку другой
name.replace('on', 'off')  # 'Pythoff'

# Почему такое странное имя метода с двумя подчеркиваниями в начале и в конце? В Python так называют методы, которые не предназначены для прямого вызова. 
# Для них созданы функции, которые внутри себя уже сами делают вызовы методов:
x = -5
abs(x)  # вызывает x.__abs__()
# -5 в 3 степени
pow(x, 3)  # вызывает x.__pow__(3)

# Кстати точно так же работает функция len():
len('Hexlet')  # Вызывает 'Hexlet'.__len__()

name = 'Shaya'
"hi, " + name.upper() + "!"  # hi, SHAYA!

num1 = 5
num2 = 30
# bit_length() - вычисляет количество бит, необходимых для представления числа в двоичном виде
print(num1.bit_length() + num2.bit_length())  # => 8

company = "hexlet"
print(company.capitalize())  # -> Hexlet

#-------------- ПАРАМЕТРЫ ФУНКЦИИ --------------

# Принимает на вход два строковых параметра
# первый - что ищем, второй - на что меняем
'google'.replace('go', 'mo'); #// 'moogle'
# Принимает на вход два числовых параметра
# первый - округляемое число, второй - число знаков после запятой, которые нужно оставить
round(10.23456, 3); #// 10.235

# get_last_char(), возвращающую последний символ в строке, переданной ему на вход как параметр. 
# Передача параметров напрямую без переменных
##get_last_char("Hexlet") # 't'
# Передача параметров через переменные
#name1 = 'Hexlet'
#get_last_char(name1) # 't'
#name2 = 'Goo'
#get_last_char(name2) # 'o'

def get_last_char(str):
    # Вычисляем индекс последнего символа как длина строки - 1
    # или return str[-1]
    return str[len(str) - 1]
# Разберем его. В скобках указывается имя параметра (str). Так как внутри функции мы не знаем, с каким конкретно значением идет работа

# функция по нахождению среднего числа
def average(a, b):
    return (a + b) / 2
average(1, 5) # 3
average(1, 2) # 1.5

# функция truncate(), обрезает переданную строку до указанного количества символов, добавляет в конце троеточие и возвращает получившуюся строку
def truncate(text, maxlength):
  result = text[0:maxlength] + '...'
  return print(result)
truncate('Даша, ты лучшая затычка для унитаза', 15) # -> Даша, ты лучшая...

def truncate(text, maxlength):
  return print(text[0:maxlength] + '...')
truncate('Маша какаша', 6) # -> Маша к...

# Еще пример:
def get_hidden_card(card, value = 4): # Или: get_hidden_card(card, value=4):
  return print(('*' * value) + card[12:16]) # Или: "visible_digits = card[-4:] ". Затем: "return f'{"*" * value}{visible_digits}' "
get_hidden_card('2034399002125581') # -> ****5581
get_hidden_card('2034399002121100', 1) # -> *1100
get_hidden_card('1234567812345678', 2) # -> **5678
#____________________________________________________________________________
# Новый урок. Проверка длины пароля
def is_correct_password(password):
    length = len(password)
    return length > 8 and length < 20
  
#def has_special_chars(str):
    # проверяет содержание специальных символов в строке
  
def is_strong_password(password):
    length = len(password)
    # Скобки задают приоритет. Понятно что к чему относится.
    return (length > 8 and length < 20) #and has_special_chars(password)

# Напишем функцию, проверяющую квартиру. Она принимает два аргумента: площадь (число) и название улицы (строку):
def is_good_apartment(area, street):
  return area >= 100 or (area >= 80 and street == 'Main Street')
print(is_good_apartment(91, 'Queens Street'))  # => False
print(is_good_apartment(120, 'Queens Street'))  # => True

# Наряду с конъюнкцией (И) и дизъюнкцией (ИЛИ), часто используется операция «отрицание».
# Отрицание меняет логическое значение на противоположное. В программировании ему соответствует унарный оператор not.
def is_even(number): # Проверка числа на четность
    return number % 2 == 0
print(not is_even(10))  # => False
print(not not is_even(10))  # => True

def is_leap_year(year):
    return (year %4 == 0 and year %100 != 0) or year %400 == 0
# Год будет високосным, если он кратен 400, или он одновременно кратен 4 и не кратен 100
print(is_leap_year(2018)) # -> False
print(is_leap_year(2017)) # -> False
print(is_leap_year(2016)) # -> True

# 0, 0.0, '', None, приводятся к False. Эти значения называют falsy. 
#____________________________________________________________________________
# Допустим нам нужно реализовать код, в котором в переменную записывается строка yes если число четное, либо no если нечетное.
print(10 % 2 == 0 and 'yes' or 'no') # => 'yes'
# число нечетное
print(11 % 2 == 0 and 'yes' or 'no') # => 'no'

# Для четного
# 1 шаг
10 % 2 == 0 # True
# 2 шаг
True and 'yes' # результат истина
# проверка на or выполняется, но правая часть не исполняется, так как сразу возвращается 'yes'

# Для нечетного
# 1 шаг
11 % 2 == 0 # False
# 2 шаг
False and 'yes' # результат ложь, проверяем дальше
# 3 шаг
False or 'no' # выбирается и возвращается 'no'
#____________________________________________________________________________
# При двойном отрицании итоговое значение равно начальному:
answer = True
print(not not answer)  # => True
# Но здесь дополнительно происходят преобразования типа. Поэтому результатом двойного отрицания всегда будет значение типа boolean.
#____________________________________________________________________________
# Функция, которая определяет тип переданного предложения. Для начала она будет отличать обычные предложения от вопросительных.
def get_type_of_sentence(sentence):
  last_char = sentence[-1]
  if last_char == '?':
      return 'question'
  return 'normal'
print(get_type_of_sentence('Hodor'))   # => normal
print(get_type_of_sentence('Hodor?'))  # => question
#____________________________________________________________________________
# Новый урок - Цикл.

#Напишем функцию с простым циклом, который будет n раз выводить на экран строку 'Hello!':
def print_hello(n):
  counter = 0
  while counter < n:
      print('Hello!')
      counter = counter + 1
print_hello(2)

def print_numbers(last_number): # Цикл, который выводит на экран числа от 1 до числа-аргумента:
  # i сокращение от index (порядковый номер)
  # используется по общему соглашению во множестве языков
  # как счетчик цикла
  i = 1
  while i <= last_number:
      print(i)
      i = i + 1
  print('finished!')
print_numbers(3)
# => 1
# => 2
# => 3
# => finished!

# Подобные конструкции index = index + 1 в Python используются довольно часто, поэтому создатели языка добавили сокращённый вариант записи: 
# index += 1.
# Существуют сокращённые формы для всех арифметических операций и для конкатенации строк:
a = a + 1 #→ a += 1
a = a - 1 #→ a -= 1
a = a * 2 #→ a *= 2
a = a / 1 #→ a /= 1

#Перед тем, как смотреть код, попробуйте ответьте на вопросы ниже:
# Каким значением инициализировать счетчик?
# Как он будет изменяться?
# Когда цикл должен остановиться?
def sum_numbers_from_range(start, finish):
    # Технически можно менять start
    # Но входные аргументы нужно оставлять в исходном значении
    # Это сделает код проще для анализа
    i = start
    sum = 0  # Инициализация суммы
    while i <= finish:  # Двигаемся до конца диапазона
        sum = sum + i   # Считаем сумму для каждого числа
        i = i + 1       # Переходим к следующему числу в диапазоне
    # Возвращаем получившийся результат
    return sum

# Для вызова sum_numbers_from_range(2, 5)
sum = 0 # Зачем вообще задавать значение? Любая повторяющаяся операция начинается с какого-то значения. 
sum = sum + 2  # 2
sum = sum + 3  # 5
sum = sum + 4  # 9
sum = sum + 5  # 14
# 14 – результат сложения чисел в диапазоне [2, 5]

# Представьте себе функцию, которая умеет «умножать» строку, то есть она повторяет её указанное количество раз:
def repeat(text, times):
    # Нейтральный элемент для строк – пустая строка
    result = ''
    i = 1
    while i <= times:
        # Каждый раз добавляем строку к результату
        result = result + text
        i = i + 1
    return result
repeat('hexlet', 3)  # 'hexlethexlethexlet'
# Распишем выполнение этого кода по шагам: Для вызова repeat('hexlet', 3)
result = ''
result = result + 'hexlet'  # hexlet
result = result + 'hexlet'  # hexlethexlet
result = result + 'hexlet'  # hexlethexlethexlet

# Функция multiply_numbers_from_range() перемножает числа указанного диапазона. Дополните недостающие места в коде:
def multiply_numbers_from_range(start, finish):
    i = start
    multiply = 1
    while i <= finish:
        multiply *= i
        i += 1
    return multiply
multiply_numbers_from_range(3, 5)  # 60
#________________________________________________________________

# Ниже пример кода, который распечатывает буквы каждого слова на отдельной строке:
def print_name_by_symbol(name):
    i = 0
    # Такая проверка будет выполняться до конца строки
    # включая последний символ. Его индекс `length - 1`.
    while i < len(name):
        # Обращаемся к символу по индексу
        print(name[i])
        i += 1
name = 'Arya'
print_name_by_symbol(name)
# => 'A'
# => 'r'
# => 'y'
# => 'a'

#======================================== =================================== =====================================
# Переворот строки (запись её задом-наперёд) — простейшая алгоритмическая задача, которую иногда задают на собеседованиях.
def reverse_string(string):
    index = len(string) - 1 # — записываем в новую переменную индекс последнего символа строки (напомним, что индексы начинаются с нуля).
    reversed_string = '' # — инициализируем строку, куда будем записывать результат.

    while index >= 0: # — условие: повторяем тело цикла, пока текущий индекс не дошёл до 0, то есть до первого символа.
        current_char = string[index] # — берём из строки символ по текущему индексу.
        reversed_string = reversed_string + current_char # — записываем в строку-результат новое значение: текущая строка-результат + новый символ.
        # То же самое через интерполяцию
        # reversed_string = f'{reversed_string}{current_char}'
        index = index - 1 # — обновляем счётчик

    return reversed_string # — когда цикл завершился, возвращаем строку-результат.
reverse_string('Game Of Thrones')  # 'senorhT fO emaG'
# Проверка нейтрального элемента
reverse_string('')  # ''
#=================================== ========================================== ========================================

# Представьте себе функцию, которая считает, сколько раз входит буква в предложение.
def count_chars(string, char):
    index = 0
    count = 0
    while index < len(string):
        if string[index] == char:
            # Считаем только подходящие символы
            count = count + 1
        # Счётчик увеличивается в любом случае
        index = index + 1
    return count
count_chars('Fear cuts deeper than swords.', 'e')  # 4
# Если вы ничего не нашли, то результат — 0 совпадений
count_chars('Sansa', 'y')  # 0

#=================================== ========================================== =======================================
# Посмотрим реализацию функции переворота строки через цикл for:

def reverse_string(text):
    # Начальное значение
    result = ''
    # char - переменная, в которую записывается текущий символ
    for char in text:
        # Соединяем в обратном порядке
        result = char + result
    # Цикл заканчивается когда пройдена вся строка
    return result
reverse_string('go!')  # => '!og'

# И для полноты картины, подсчет количества упоминаний символа в строке без учета регистра:

# text - произвольный текст
# char - символ, который нужно учитывать
def chars_count(text, char):
    # Так как ищем сумму, то начальное значение 0
    result = 0
    for current_char in text:
        # приводим все к нижнему регистру,
        # чтобы не зависеть от текущего регистра
        if current_char.lower() == char.lower():
            result += 1
    return result
chars_count('hexlet!', 'e')  # 2
chars_count('hExlet!', 'e')  # 2
chars_count('hExlet!', 'E')  # 2
chars_count('hexlet!', 'a')  # 0